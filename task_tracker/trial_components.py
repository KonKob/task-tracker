# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_trial_components.ipynb.

# %% auto 0
__all__ = ['Proband', 'Trial', 'Task', 'Pause', 'Audio_Record', 'Task_History']

# %% ../nbs/01_trial_components.ipynb 3
import time
import datetime
from typing import List
from pathlib import Path

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from scipy.io.wavfile import write
import numpy as np
import speech_recognition as sr

from .utils import get_duration_in_s_from_timestamps, transcribe_audio_to_task, create_cumulative_bar_plots, create_timeline, create_cumulative_tie_plots, create_cumulative_dataframe, save_trial, create_cumulative_pie_plots_per_lane, create_cumulative_bar_plots_per_lane, get_colors

# %% ../nbs/01_trial_components.ipynb 4
class Proband():
    
    def __init__(self, proband_ID):
        self.metadata = {}
        self.proband_ID = proband_ID
    
    def set_metadata(self, metadata, metadata_name):
        self.metadata[metadata_name]=metadata

# %% ../nbs/01_trial_components.ipynb 5
class Trial():
    
    def __init__(self, user_ID, task_dict, demographic_dict, target_dir = None, proband_ID = None, colors = None):
        self.task_dict = task_dict
        self.demographic_dict = demographic_dict
        self.user_ID = user_ID
        self.task_number = 0
        self.start_time = None
        self.out_dir = None
        self.started = False
        self.colors = colors
        if target_dir is None or not target_dir.exists():
            self.target_dir = Path.cwd()
        else:
            self.target_dir = target_dir
        if proband_ID is None:
            proband_ID = self._get_next_proband_ID()
        self.history = Task_History(task_dict)
        self.proband = Proband(proband_ID)
        self.audio_record = Audio_Record(trial=self)
    
    def set_start_time(self, overwrite=False):
        if self.start_time is None and not overwrite:
            self.start_time = round(time.time(), 4)
            self.start_struct_time = time.gmtime()
        self.out_dir = self.target_dir.joinpath(f"{time.strftime('%Y-%m-%d_%H.%M.%S', self.start_struct_time)}_{self.proband.proband_ID}_{self.user_ID}/")
        self.started = True
        Path.mkdir(self.out_dir)
        
    def end_trial(self):
        self.end_time = round(time.time(), 4)
        self.end_struct_time = time.gmtime()
        
        save_trial(self)
        
    def export_results(self):
        self.export_tasks()
        self.export_tasks_per_subtasks()
        self.export_proband_information()

        save_trial(self)
        
        return self.tasks_dataframe, self.cum_d, self.dataframe_per_subtasks, self.plots, self.subtask_plots, self.metadata_df
        
    def export_tasks(self):       
        self._postprocess_tasks_and_descriptions()
        self.tasks_dataframe = self.history.export_tasks(self.start_time)
        self.tasks_dataframe.to_excel(self.out_dir.joinpath(f"{time.strftime('%Y-%m-%d_%H.%M.%S', self.end_struct_time)}_tasks.xlsx"))

        task_names = self.tasks_dataframe["task_name"].unique()
        if self.colors is None:
            self.colors = get_colors(task_names)
            
        for task_name in task_names:
            if task_name not in self.colors:
                self.colors[task_name] = sns.colors.xkcd_rgb["black"]
        
        self.plots = {}
        for func, name in [(create_timeline, "timeline"), (create_cumulative_bar_plots, "cumulative_bar_plots"), (create_cumulative_tie_plots, "cumulative_tie_plots")]:
            fig = func(self.tasks_dataframe, task_names = task_names, colors = self.colors)
            self.plots[name] = fig
            fig.savefig(self.out_dir.joinpath(f"{time.strftime('%Y-%m-%d_%H.%M.%S', self.end_struct_time)}_{name}.png"))
        
        self.cum_d = create_cumulative_dataframe(self.tasks_dataframe)
        self.cum_d.to_excel(self.out_dir.joinpath(f"{time.strftime('%Y-%m-%d_%H.%M.%S', self.end_struct_time)}_tasks_cumulative_duration.xlsx"))
        
        save_trial(self)
        
        return self.plots, self.tasks_dataframe, self.cum_d
    
    def export_proband_information(self):
        self.metadata_df = pd.DataFrame(self.proband.metadata, columns=self.proband.metadata.keys(), index=[self.proband.proband_ID])
        self.metadata_df.to_excel(self.out_dir.joinpath(f"{time.strftime('%Y-%m-%d_%H.%M.%S', self.end_struct_time)}_proband_metadata.xlsx"))
        
        save_trial(self)
        
        return self.metadata_df
        
    def export_tasks_per_subtasks(self):
        tasks = {}
        for lane in self.history.tasks:
            for task in self.history.tasks[lane]:
                if task.task_name != "Pause":
                    if task.task_name not in tasks:
                        tasks[task.task_name] = {}
                    end = task.end_time
                    start = task.start_time
                    
                    for sub_lane in self.history.tasks:
                        if sub_lane != lane:
                            for subtask in self.history.tasks[sub_lane]:
                                
                                if subtask.start_time < end and subtask.end_time > start:
                                    duration = subtask.calculate_duration(start, end)
                                    if subtask.task_name not in tasks[task.task_name]:
                                        tasks[task.task_name][subtask.task_name] = duration
                                    else:
                                        tasks[task.task_name][subtask.task_name] += duration

        self.dataframe_per_subtasks = pd.DataFrame(tasks)
        self.dataframe_per_subtasks.to_excel(self.out_dir.joinpath(f"{time.strftime('%Y-%m-%d_%H.%M.%S', self.end_struct_time)}_subtasks_per_tasks.xlsx"))

        self.subtask_plots = {}
        for func, name in [(create_cumulative_bar_plots_per_lane, "bar_plots_per_lane"), (create_cumulative_pie_plots_per_lane, "pie_plots_per_lane")]:
            fig = func(self.dataframe_per_subtasks)
            self.subtask_plots[name] = fig
            fig.savefig(self.out_dir.joinpath(f"{time.strftime('%Y-%m-%d_%H.%M.%S', self.end_struct_time)}_{name}.png"))
            
        save_trial(self)
            
        return self.subtask_plots, self.dataframe_per_subtasks
        
        
    def _get_next_proband_ID(self):
        probands = []
        for file in self.target_dir.iterdir():
            if file.is_dir():
                try:
                    timestemp_day, timestemp_time, old_proband_ID, user_ID = file.name.split("_")
                    probands.append(old_proband_ID)
                except ValueError:
                    pass
        if probands:
            probands.sort()
            proband_ID = str(int(probands[-1])+1).zfill(4)
        else:
            proband_ID = "0000"
        return proband_ID
        
    def _postprocess_tasks_and_descriptions(self):
        r = sr.Recognizer()
        file = sr.AudioFile(self.audio_record.filename)

        for lane in self.history.tasks:
            for task in self.history.tasks[lane]:
                if type(task)==Task:
                    transcribe_audio_to_task(task, r, file, self)

# %% ../nbs/01_trial_components.ipynb 6
class Task():
    
    def __init__(self, task_number, task_name, lane):
        self.task_name = task_name
        self.task_number = task_number
        self.lane = lane
        self.start_time = None
        self.end_time = None
        self.paused = False
        self.running = False
        self.currently_paused = False
        self.pauses = []
        self.pause = None
        self.description = []
    
    def start(self):
        if not self.running:
            self.running = True
            self.start_time = round(time.time(), 4)
    
    def pause_start(self):
        if not self.currently_paused:
            self.paused = True
            self.currently_paused = True
            self.pause = Pause(self.task_number, lane=self.lane)
            self.pause.start()
    
    def end(self):
        if self.running:
            self.end_time = round(time.time(), 4)
            self.pause_end()
            self.running = False
            self.duration_in_s = self.calculate_duration()
            
    def calculate_duration(self, start_time=None, end_time=None):
        if start_time is None: 
            start_time = self.start_time
        elif start_time < self.start_time:
            start_time = self.start_time
        if end_time is None:
            end_time = self.end_time
        elif end_time > self.end_time:
            end_time = self.end_time
        
        if self.paused is False:
            duration = get_duration_in_s_from_timestamps(start_time, end_time)
        else:
            duration = get_duration_in_s_from_timestamps(start_time, end_time)
            for pause in self.pauses:
                if pause.start_time < end_time and pause.end_time > start_time:
                    duration -= pause.calculate_duration(start_time, end_time)
        
        return duration
    
    def pause_end(self):
        if self.currently_paused:
            self.currently_paused = False
            self.pause.end()
            self.pauses.append(self.pause)
            self.pause = None
            
    def add_description(self, description):
        if description:
            self.description.append(description)

# %% ../nbs/01_trial_components.ipynb 7
class Pause():
    
    def __init__(self, task_number, task_name="Pause", lane="Tasks"):
        self.task_name = task_name
        self.task_number = task_number
        self.start_time = None
        self.end_time = None
        self.lane = lane
        self.description = []
    
    def start(self):
        self.start_time = round(time.time(), 4)
    
    def end(self):
        self.end_time = round(time.time(), 4)
        self.duration_in_s = self.calculate_duration()
        
    def calculate_duration(self, start_time=None, end_time=None):
        if start_time is None: 
            start_time = self.start_time
        elif start_time < self.start_time:
            start_time = self.start_time
        if end_time is None:
            end_time = self.end_time
        elif end_time > self.end_time:
            end_time = self.end_time
        
        duration = get_duration_in_s_from_timestamps(start_time, end_time)
        
        return duration

# %% ../nbs/01_trial_components.ipynb 8
class Audio_Record():
    def __init__(self, trial, channels = 1, freq = 44100, duration = 10800):
        import sounddevice as sd
        self.channels = channels
        self.freq = freq
        self.duration = duration
        self.trial = trial
        self.filename = None
        self.recording = np.array([])
        self.running = False
    
    def start(self):
        if not self.running:
            self.start_time=round(time.time(), 4)
            self.recording = sd.rec(int(self.duration * self.freq), 
                       samplerate=self.freq, channels=self.channels)
            self.running = True
            self.filename = str(self.trial.out_dir.joinpath(f"{time.strftime('%Y-%m-%d_%H.%M.%S', time.gmtime())}.WAV"))
        
    def end(self):
        if self.running:
            self.end_time=round(time.time(), 4)
            sd.stop()
            real_duration = get_duration_in_s_from_timestamps(self.start_time, self.end_time)
            self.recording = self.recording[:int(real_duration*self.freq)]
            y = (np.iinfo(np.int32).max * (self.recording/np.abs(self.recording).max())).astype(np.int32)
            write(self.filename, self.freq, y)
            self.running = False

# %% ../nbs/01_trial_components.ipynb 9
class Task_History():
    
    def __init__(self, task_dict):
        self.tasks = self._create_tasks_dict(task_dict)
        self.current_tasks = {}
        self.dataframe = None
        
    def add_current_task_to_history(self, lane):
        self.tasks[lane].append(self.current_tasks[lane])
        
    def add_pause(self, pause):
        self.tasks["Pause"].append(pause)
        
    def export_tasks(self, time_zero = None):
        self.dataframe = pd.DataFrame()
        tasks = []
        for lane in self.tasks:
            tasks += self.tasks[lane]
        self.dataframe["lane"] = [task.lane for task in tasks]
        self.dataframe["duration_in_s"] = [task.duration_in_s for task in tasks]
        self.dataframe["task_number"] = [task.task_number for task in tasks]
        self.dataframe["task_name"] = [task.task_name for task in tasks]
        if time_zero is None:
            self.dataframe["start_time"] = [task.start_time for task in tasks]
            self.dataframe["end_time"] = [task.end_time for task in tasks]
        else:
            self.dataframe["start_time"] = [task.start_time-time_zero for task in tasks]
            self.dataframe["end_time"] = [task.end_time-time_zero for task in tasks]
        for lane in self.tasks:
            for task in self.tasks[lane]:
                for i, description in enumerate(task.description):
                    self.dataframe.loc[self.dataframe["task_number"]==task.task_number, f"description_{i}"] = description
        return self.dataframe
    
    
    def _create_tasks_dict(self, task_dict):
        tasks = {"Pause": []}
        if type(task_dict) == dict:
            for lane in task_dict:
                tasks[lane] = []
        elif type(task_dict) == list:
            tasks["Tasks"] = []
        return tasks
